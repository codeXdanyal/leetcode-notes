# LeetCode Problem 155: Min Stack
**Leetcode Problem Link:** https://leetcode.com/problems/min-stack/description/

## Table of Contents
- [Problem Description](#problem-description)
- [Problem Understanding](#problem-understanding)
- [Key Observations](#key-observations)
- [Constraints Analysis](#constraints-analysis)
- [Edge Cases](#edge-cases)
- [My Approach (Step-by-Step)](#my-approach-step-by-step)
- [Why This Approach Works](#why-this-approach-works)
- [Time and Space Complexity](#time-and-space-complexity)
- [Complete Code Implementation](#complete-code-implementation)
- [Dry Run](#dry-run)

## Problem Description
You are asked to implement a stack that supports not only the standard stack operations (push, pop, and top) but also allows retrieving the minimum element in constant time. Normally, finding the minimum element in a stack would take O(n) time, but the goal here is to achieve O(1) for all operations.

## Problem Understanding
You need to implement a stack that supports the standard operations (`push`, `pop`, `top`) and can also return the **minimum element** in constant time. Normally, finding the minimum in a stack would require scanning all elements, but the goal here is to make all operations O(1).  


## Key Observations
A single stack cannot efficiently track the minimum. Using a **second stack** allows you to keep track of the current minimum at each point. Every time a new element is pushed that is smaller than or equal to the current minimum, it is also pushed onto the minimum stack. When popping, if the popped element equals the top of the minimum stack, it is removed from the minimum stack as well.  


## Constraints Analysis
- All operations must execute in O(1) time.  
- The stack can store any integer values, including duplicates and negative numbers.  
- The solution must correctly maintain the minimum even after multiple push and pop operations.  


## Edge Cases
- The stack is empty when `pop` or `top` is called (can assume valid operations or handle separately).  
- Multiple elements have the same minimum. Removing one should not change the minimum if duplicates exist.  
- Large integer values and negative numbers must be handled correctly.  


## My Approach (Step-by-Step)
1. Initialize two stacks (vectors): `v` for the main stack and `m` for tracking the minimum values.  
2. **Push operation:** Add the value to `v`. If `m` is empty or the value is smaller than or equal to `m.back()`, push it to `m` as well.  
3. **Pop operation:** Remove the top value from `v`. If it equals `m.back()`, pop it from `m` too.  
4. **Top operation:** Return `v.back()`.  
5. **GetMin operation:** Return `m.back()`, which always stores the current minimum value.  


## Why This Approach Works
The second stack `m` only stores elements that could be the current minimum. Every time the minimum changes, it is updated in `m`. This ensures that `m.back()` always contains the smallest element in the stack. By mirroring the minimum elements, we achieve O(1) time for all operations, without scanning the main stack.  


## Time and Space Complexity
**Time Complexity:** O(1) for push, pop, top, and getMin operations.  
**Space Complexity:** O(n) in the worst case, where all elements are pushed into both the main stack and the minimum stack.  


## Complete Code Implementation
```cpp
class MinStack {
public:
    vector<int> v, m; 

    void push(int val) {
        v.push_back(val);              
        if (m.empty() || val <= m.back()) {
            m.push_back(val);          
        }
    }

    void pop() {
        if (v.back() == m.back()) {
            m.pop_back();             
        }
        v.pop_back();                  
    }

    int top() {
        return v.back();              
    }

    int getMin() {
        return m.back();               
    }
};
```
## Dry Run

Consider the sequence: `push(5), push(3), push(7), push(3), getMin(), pop(), getMin(), pop(), top()`

1. `push(5)` → `v = [5]`, `m = [5]`
2. `push(3)` → `v = [5,3]`, `m = [5,3]`
3. `push(7)` → `v = [5,3,7]`, `m = [5,3]`
4. `push(3)` → `v = [5,3,7,3]`, `m = [5,3,3]`
5. `getMin()` → returns `3` (top of `m`)
6. `pop()` → remove `3` → `v = [5,3,7]`, `m = [5,3]`
7. `getMin()` → returns `3`
8. `pop()` → remove `7` → `v = [5,3]`, `m = [5,3]`
9. `top()` → returns `3` (top of `v`)
