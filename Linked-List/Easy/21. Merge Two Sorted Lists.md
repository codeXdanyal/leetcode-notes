# Merge Two Sorted Linked Lists

## What This Means
We are asked to combine two already sorted linked lists into a single sorted list. Since both lists are sorted, we don’t need to sort anything again we can just pick the smaller node from the two lists at each step. Think of it like merging two sorted decks of cards: you always take the smaller top card until all cards are in one deck.

We use a **dummy node** at the start to make building the merged list easier. This dummy node acts as a placeholder, so we don’t have to handle special cases for the first node. A `current` pointer keeps track of the last node in the merged list, letting us easily append the next smallest node.


## Step-by-Step Approach

1. **Handle Base Cases**  
   - If `list1` is empty, return `list2`.  
   - If `list2` is empty, return `list1`.  

    This avoids unnecessary processing if one list has no nodes.

2. **Initialize Dummy Node**  
   - Create a `dummyHead` node to act as the starting point of the merged list.  
   - Use a `current` pointer to keep track of the last node in the merged list.

3. **Iteratively Merge Nodes**  
   - While both lists have nodes:  
     - Compare the current nodes of `list1` and `list2`.  
     - Attach the smaller node to `current->next`.  
     - Move the pointer forward in the list from which the node was taken.  
     - Move the `current` pointer forward to the newly added node.

4. **Attach Remaining Nodes**  
   - After one list ends, attach the remaining nodes of the other list to `current->next`.  
   - Since the remaining nodes are already sorted, no additional sorting is needed.

5. **Return Merged List**  
   - Skip the dummy node and return `dummyHead->next` as the head of the merged list.


## Example

**Input:**  
```text
list1: 1 → 2 → 4
list2: 1 → 3 → 4
```

**Output:**  
```text
1 → 1 → 2 → 3 → 4 → 4
```

**Explanation:**  
- Compare `1` and `1` → pick the first `1`.  
- Compare `2` and `1` → pick `1`.  
- Compare `2` and `3` → pick `2`.  
- Compare `4` and `3` → pick `3`.  
- Attach remaining nodes → `4 → 4`.


## Complexity Analysis

**Time Complexity:**  
Every node from both lists is processed exactly once, so the time complexity is:  
`O(n + m)`

where `n` and `m` are the lengths of `list1` and `list2`.

**Space Complexity:**  
Only a few pointers (`dummyHead` and `current`) are used. No extra nodes are created besides the dummy.  
`O(1)`


## C++ Implementation

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // Base cases: if one list is empty, return the other
        if (!list1) return list2;
        if (!list2) return list1;

        // Initialize dummy node
        ListNode* dummyHead = new ListNode();
        ListNode* current = dummyHead;

        // Merge nodes from both lists
        while (list1 && list2) {
            if (list1->val <= list2->val) {
                current->next = list1;
                list1 = list1->next;
            } else {
                current->next = list2;
                list2 = list2->next;
            }
            current = current->next;
        }

        // Attach remaining nodes
        current->next = list1 ? list1 : list2;

        // Return head of merged list (skip dummy)
        return dummyHead->next; 
    }
};