# LeetCode Problem 21: Merge Two Sorted Linked Lists
**Leetcode Problem Link:**

## Table of Contents
- [Problem Description](#problem-description)
- [Problem Understanding](#problem-understanding)
- [Key Observations](#key-observations)
- [Constraints Analysis](#constraints-analysis)
- [Edge Cases](#edge-cases)
- [My Approach (Step-by-Step)](#my-approach-step-by-step)
- [Why This Approach Works](#why-this-approach-works)
- [Time and Space Complexity](#time-and-space-complexity)
- [Complete Code Implementation](#complete-code-implementation)
- [Dry Run](#dry-run)
- [Roman Urdu Notes](#roman-urdu-notes)

## Problem Description
You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

## Example 1:
```cpp
Input:  list1 = [1,2,4], list2 = [1,3,4]` 

Output: [1,1,2,3,4,4]
```

## Example 2:
```cpp
Input:  list1 = [], list2 = []

Output: []
```

### Example 3:
```cpp
Input:  list1 = [], list2 = [0]

Output: [0]
 ```

### Constraints:

- The number of nodes in both lists is in the range [0, 50].
- `-100 <= Node.val <= 100`
- Both list1 and list2 are sorted in non-decreasing order.

## Problem Understanding
You are given the heads of two singly linked lists. Both linked lists are already sorted in ascending order. Your task is to merge these two lists into one single linked list that is also sorted in ascending order. The merged list should be formed by reusing the existing nodes from the original lists, not by creating new nodes for each value. Finally, you must return the head of this merged linked list.

## Key Observations
Because both linked lists are already sorted, you do not need to perform any sorting operation again. At each step, you only need to compare the current node values of both lists and select the smaller one. A dummy node can be used to simplify the merging process, especially to avoid special handling for the first node of the merged list.

## Constraints Analysis
The number of nodes in both lists can range from 0 to 50, and each node’s value can range between -100 and 100. Either one or both lists can be empty. These constraints are small, so efficiency is not a concern, but correctness and clarity are important. The fact that lists are already sorted is the most important constraint that allows an efficient linear solution.

## Edge Cases
If the first list is empty, the merged result is simply the second list. If the second list is empty, the merged result is the first list. If both lists are empty, the result is also empty. Handling these cases early avoids unnecessary traversal and prevents null pointer issues.

## My Approach (Step-by-Step)
Start by checking if either of the linked lists is empty and return the other list if so. Then create a dummy node that acts as a placeholder for the merged list. Use a pointer called `current` that always points to the last node in the merged list. While both lists still have nodes, compare their current values and attach the smaller node to `current->next`. Move forward in the list from which the node was taken, and also move the `current` pointer forward. Once one list becomes empty, attach the remaining nodes of the other list directly, since they are already sorted. Finally, return the node next to the dummy node as the head of the merged list.

## Why This Approach Works
This approach works because the sorted nature of both lists guarantees that choosing the smaller current value at each step will keep the merged list sorted. The dummy node simplifies the logic by eliminating special cases for initializing the head. The algorithm modifies pointers in place, so no extra memory is wasted on creating new nodes.

## Time and Space Complexity
The algorithm traverses each node of both lists exactly once, so the time complexity is `O(n + m)`, where `n` and `m` are the lengths of the two lists. The space complexity is `O(1)` because no additional data structures are used, apart from a few pointers.

## Complete Code Implementation
```cpp 
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {

        // If one list is empty, return the other
        if (!list1) return list2;
        if (!list2) return list1;

        // Dummy node to simplify merging
        ListNode* dummyHead = new ListNode();
        ListNode* current = dummyHead;

        // Merge both lists
        while (list1 && list2) {
            if (list1->val <= list2->val) {
                current->next = list1;
                list1 = list1->next;
            } else {
                current->next = list2;
                list2 = list2->next;
            }
            current = current->next;
        }

        // Attach remaining nodes
        current->next = list1 ? list1 : list2;

        // Return merged list (skip dummy node)
        return dummyHead->next;
    }
};
```

## Dry Run
### Input
```text
list1: 1 → 2 → 4  
list2: 1 → 3 → 4
```
### Step-by-Step Execution

- Dummy node is created and `current` points to it.
- Compare `1` (list1) and `1` (list2), pick `1` from list1.
- Compare `2` (list1) and `1` (list2), pick `1` from list2.
- Compare `2` (list1) and `3` (list2), pick `2` from list1.
- Compare `4` (list1) and `3` (list2), pick `3` from list2.
- Compare `4` (list1) and `4` (list2), pick `4` from list1.
- List1 ends, attach remaining node `4` from list2.

### Output
```text
1 → 1 → 2 → 3 → 4 → 4
```

The final merged linked list is sorted, and all nodes are reused without creating any new data nodes.

```text
1 → 2 → 3 → 4
```

# Roman Urdu Notes

## Problem Understanding
Aap ko do singly linked lists ke heads diye gaye hain. Dono linked lists pehle se ascending order mein sorted hain. Aap ka task ye hai ke in dono lists ko merge karke aik single linked list banayi jaye jo ke ascending order mein hi sorted ho. Merged list ko original lists ke existing nodes reuse karke banana hai, har value ke liye naye nodes create nahi karne. Aakhir mein, aap ko is merged linked list ka head return karna hai.

## Key Observations
Kyun ke dono linked lists pehle se sorted hain, is liye dobara sorting karne ki koi zarurat nahi hoti. Har step par sirf dono lists ke current node values ko compare karna hota hai aur choti value wale node ko select karna hota hai. Aik dummy node use ki ja sakti hai jo merging process ko simplify karti hai, khaas tor par merged list ke pehle node ke special handling se bachne ke liye.

## Constraints Analysis
Dono lists mein nodes ki total tadaad 0 se 50 ke darmiyan ho sakti hai, aur har node ki value -100 se 100 ke beech ho sakti hai. Ya to aik list empty ho sakti hai ya dono bhi empty ho sakti hain. Ye constraints choti hain, is liye performance koi issue nahi hota, lekin correctness aur clarity bohat important hoti hai. Lists ka pehle se sorted hona sab se important constraint hai jo humein aik efficient linear solution deta hai.

## Edge Cases
Agar pehli list empty ho, to merged result seedha doosri list ho gi. Agar doosri list empty ho, to merged result pehli list ho gi. Agar dono lists empty hon, to result bhi empty ho ga. In cases ko start mein handle karna unnecessary traversal se bachata hai aur null pointer issues ko prevent karta hai.

## My Approach (Step-by-Step)
Sab se pehle check karo ke kya dono mein se koi aik linked list empty hai, aur agar hai to doosri list return kar do. Phir aik dummy node create karo jo merged list ke liye placeholder ka kaam karti hai. Aik pointer `current` use karo jo hamesha merged list ke last node ko point karta hai. Jab tak dono lists mein nodes mojood hain, un ki current values compare karo aur choti value wale node ko `current->next` ke sath attach kar do. Us list mein aage move karo jahan se node liya gaya tha, aur sath hi `current` pointer ko bhi aage move karo. Jab aik list khatam ho jaye, to doosri list ke remaining nodes ko directly attach kar do kyun ke wo pehle se sorted hotay hain. Aakhir mein, dummy node ke next wale node ko merged list ka head bana kar return kar do.

## Why This Approach Works
Ye approach is liye kaam karti hai kyun ke dono lists ka sorted hona guarantee karta hai ke har step par choti current value choose karne se merged list sorted hi rahe gi. Dummy node logic ko simplify kar deti hai aur head initialize karne ke special cases khatam ho jatay hain. Algorithm pointers ko in-place modify karta hai, is liye extra memory new nodes banane mein waste nahi hoti.

## Time and Space Complexity
Algorithm dono lists ke har node ko sirf aik dafa traverse karta hai, is liye time complexity `O(n + m)` hoti hai, jahan `n` aur `m` dono lists ki lengths hain. Space complexity `O(1)` hoti hai kyun ke kuch pointers ke ilawa koi additional data structures use nahi kiye jatay.