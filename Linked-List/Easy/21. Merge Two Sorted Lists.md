# Intuition
We are asked to merge two sorted linked lists into a single sorted linked list. Since both lists are already sorted, we can merge them similarly to the merge step in merge sort. We traverse both lists simultaneously and pick the smaller node at each step, building the merged list iteratively.

# Approach
1. Handle base cases: if either `list1` or `list2` is `nullptr`, return the other list directly.
2. Create a dummy node `dummyHead` to simplify list construction and maintain a `current` pointer to track the last node in the merged list.
3. While both lists have nodes:
   - Compare the current nodes of `list1` and `list2`.
   - Append the smaller node to `current->next`.
   - Move the pointer of the list from which the node was taken.
   - Move the `current` pointer forward.
4. After the loop, one list may still have remaining nodes. Attach the remaining nodes to `current->next`.
5. Return `dummyHead->next` to skip the dummy node and get the head of the merged list.

This approach ensures that the merged list remains sorted, and we iterate through each node exactly once.

# Complexity
- **Time complexity:**  
  We traverse each node of both lists exactly once, so the time complexity is:  
  $$O(n + m)$$  
  where \(n\) and \(m\) are the lengths of `list1` and `list2`.

- **Space complexity:**  
  We only use a few pointers (`dummyHead`, `current`) and do not allocate extra nodes (other than the dummy), so the space complexity is:  
  $$O(1)$$
# Code
```cpp []
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
       if (list1 == nullptr) return list2;
        if (list2 == nullptr) return list1;

        ListNode* dummyHead = new ListNode();
        ListNode* current = dummyHead;

        while (list1 && list2) {
            if (list1->val <= list2->val) {
                current->next = list1;
                list1 = list1->next;
            } else {
                current->next = list2;
                list2 = list2->next;
            }
            current = current->next;
        }
        current->next = list1 ? list1 : list2;

        return dummyHead->next; 

    }
};
```